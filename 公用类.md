## GlobalExceptionHandler

全局异常处理

```java
import com.ikang.bprom.common.response.CommonResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    @ResponseBody
    public CommonResponse handleException(Exception ex){
        if(ex instanceof BusinessException){
            return new CommonResponse(((BusinessException) ex).getCode(), ex.getMessage());
        }
        log.error("error:",ex);
        return new CommonResponse(-1, "系统内部异常");
    }
}
```

### BusinessException自定义异常

```java
import com.ikang.bprom.common.response.CommonResponse;
import lombok.Data;

@Data
public class BusinessException extends RuntimeException {

    private static final long serialVersionUID = 8559762123103088030L;
    private final int code;
    private final String msg;



    public BusinessException(String msg) {
        this(-1, msg);
    }

    public BusinessException(CommonResponse<?> result) {
        super(result.getMsg());
        this.code = result.getCode();
        this.msg = result.getMsg();
    }
    public BusinessException(int code, String msg) {
        super(msg);
        this.code = code;
        this.msg = msg;
    }
}
```

### CommonResponse返回前端

```java
import lombok.Data;


@Data
public class CommonResponse<T> {

    public final static int SUCCESS_CODE = 200;

    /**
     * 0:定义为成功
     * -1:定义为失败，fail
     * 302:定义为跳转
     */
    private final static CommonResponse INSTANCE_SUCCESS = new CommonResponse(SUCCESS_CODE, "SUCCESS");
    private final static CommonResponse INSTANCE_FAIL = new CommonResponse(-1, "fail");
    public final static CommonResponse UNLOGIN = new CommonResponse(302, "fail");
    private int code = 200;
    private String msg = "SUCCESS";
    private T data = null;

    public CommonResponse(){
    }

    public CommonResponse(T t) {
        data = t;
    }

    public CommonResponse(int code, String info) {
        this.code = code;
        this.msg = info;
    }

    public CommonResponse(int code, String info, T t) {
        this.code = code;
        this.msg = info;
        this.data  = t;
    }

    public final static CommonResponse success() {
        return INSTANCE_SUCCESS;
    }
    public final static <T> CommonResponse success(T data) {
        return new CommonResponse(SUCCESS_CODE,"success",data);
    }

    public final static CommonResponse fail() {
        return INSTANCE_FAIL;
    }
    public final static  CommonResponse fail(String msg) {
        return new CommonResponse(-1,msg);
    }
}
```

### ErrorCode错误码枚举服务类

```java
/**
 * 错误码枚举服务类
 * 使用枚举类型来封装异常码和异常信息
 *
 */
public enum ErrorCode {

    SUCCESS("0", "success"),
    FAIL("-1", "failure"),
    ;

    private String code;
    private String msg;

    ErrorCode(String code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public String getMsg() {
        return this.msg;
    }

    public String getCode() {
        return this.code;
    }
}
```



## EasyExcel工具类

### HeaderUtils设置EasyExcel的请求头

```java
import org.apache.tomcat.util.http.fileupload.FileUploadBase;

import javax.servlet.http.HttpServletResponse;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

import static org.springframework.http.HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS;
import static org.springframework.http.HttpHeaders.CONTENT_DISPOSITION;


public class HeaderUtils {
    public static final String APPLICATION_VND_MS_EXCEL = "application/vnd.ms-excel";
    public static final String REPLACEMENT = "%20";
    public static final String ATTACHMENT_FILE_NAME = "attachment;filename*=utf-8''";
    public static final String XLSX = ".xlsx";

    /**
     * @param response 响应
     * @param title    表名
     * @throws UnsupportedEncodingException 异常
     * @author <a href="mailto:hao.liu-ext@ikang.com">hao.liu</a>
     * @date: 2022/2/18 19:38
     */
    public static void setExcelHeader(HttpServletResponse response, String title) throws UnsupportedEncodingException {
        //设置返回的数据格式
        response.setContentType(APPLICATION_VND_MS_EXCEL);
        //设置返回的数据编码
        response.setCharacterEncoding(StrPool.UTF_8);
        // 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系
        String fileName = URLEncoder.encode(title, StrPool.UTF_8).replaceAll("\\+", REPLACEMENT);
//        String fileName = "电商主题";
        response.setHeader(CONTENT_DISPOSITION, ATTACHMENT_FILE_NAME + fileName + XLSX);
        // 服务端要在header设置Access-Control-Expose-Headers, 前端才能正常获取到
        response.setHeader(ACCESS_CONTROL_EXPOSE_HEADERS, FileUploadBase.CONTENT_DISPOSITION);
    }
}
```

使用示例:

```java
//设置导出header
HeaderUtils.setExcelHeader(response, "B端推送记录");
//导出
EasyExcel.write(response.getOutputStream(), CheckPushRecordsTableVo.class).sheet("B端推送记录").doWrite(data);
```

## 通用工具类

### CheckUtil

```java
import com.ikang.bprom.common.enums.ResultEnum;
import com.ikang.bprom.common.exception.BusinessException;
import com.ikang.bprom.common.response.CommonResponse;

import java.util.function.Consumer;
import java.util.function.Predicate;

public class CheckUtil {

    public static void isTrue(Boolean b, Exception e) throws Exception {
        if (b) {
            throw e;
        }
    }

    public static <T> void check(T key, Predicate<T> predicate, Consumer<T> consumer) {
        if (predicate.test(key)) {
            consumer.accept(key);
        }
    }

    public static void isTrue(Boolean b, InternalProcess process) {
        if (b) {
            process.process();
        }
    }

    public static <T> T checkResult(CommonResponse<T> result) {
        if (!ResultEnum.SUCCESS.getCode().equals(result.getCode())) {
            throw new BusinessException(result);
        }
        return result.getData();
    }

    @FunctionalInterface
    public interface InternalProcess {
        /**
         * 默认方法
         */
        void process();
    }
}
```

使用示例

```java
//isTrue方法  为空抛出异常
CheckUtil.isTrue(userList.size() == MagicConst.INT_0, new BusinessException("用户不存在，请检查"));
//或者为空 添加某一条件
CheckUtil.isTrue(StrUtil.isNotEmpty(vo.getProjectid()),
                () -> must.add(QueryBuilders.termsQuery(ActualdiscountEnum.projectid.getFields(), vo.getProjectid().split(COMMA_SPLIT))));
```



### DateUtils 日期工具类

```java
package com.ikang.bprom.common.util;

import cn.hutool.core.date.DateTime;
import cn.hutool.core.util.IdcardUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;

/**
 * @author <a href="mailto:wenyue.gao@ikang.com">wenyue.gao</a>
 * @description
 * @date 2020/11/17
 */
@Slf4j
public class DateUtil {

    /**
     * 日期格式 年 如2009
     */
    public static final String DATEFORMATYEAR = "yyyy";

    /**
     * 日期格式 年 月  如 2009-02
     */
    public static final String DATEFORMATMONTH = "yyyy-MM";

    /**
     * 日期格式 年 月  如 200902
     */
    public static final String DATEFORMATMONTH2 = "yyyyMM";

    /**
     * 日期格式 年 月 日 如2009-02-26
     */
    public static final String DATEFORMATDAY = "yyyy-MM-dd";

    /**
     * 日期格式 年 月 日 如2009/02/26
     */
    public static final String DATEFORMATDAYSLASH = "yyyy/MM/dd";

    /**
     * 日期格式 年 月 日 时 如2009-02-26 15
     */
    public static final String DATEFORMATHOUR = "yyyy-MM-dd HH";

    /**
     * 日期格式 年 月 日 时 分 如2009-02-26 15:40
     */
    public static final String DATEFORMATMINUTE = "yyyy-MM-dd HH:mm";

    /**
     * 日期格式年 月 日 时 分 秒 如 2009-02-26 15:40:00
     */
    public static final String DATEFORMATSECOND = "yyyy-MM-dd HH:mm:ss";

    /**
     * 日期格式年 月 日 时 分 秒 毫秒 如2009-02-26 15:40:00 110
     */
    public static final String DATEFORMATMILLISECOND = "yyyy-MM-dd HH:mm:ss SSS";

    /**
     * 日期格式年 月 日 时 分 秒 毫秒 如2009-02-26 15:40:00.110
     */
    public static final String DATEFORMATMILL ="yyyy-MM-dd HH:mm:ss.SSS";

    /**
     * 日期格式年 月 日 如2009年2月26日
     */
    public static final String DATEFORMATDAYCN = "yyyy年MM月dd日";

    public static final String DATEFORMATDAY2 = "yyyyMMdd";

    /**
     * 按指定的格式，把Date转换成String 如date为null,返回null
     *
     * @param date
     *            Date参数
     * @param format
     *            日期格式
     * @return String
     */
    public static String format(Date date, String format) {
        if (date == null) {
            return null;
        }
        return new SimpleDateFormat(format).format(date);
    }

    /**
     * 按指定的格式，把string转换成Date 如string为空或null，返回null
     *
     * @param string
     * @param format
     * @return
     * @throws ParseException
     */
    public static Date paraseStr(String string, String format)  {
        if (StringUtils.isEmpty(string)) {
            return null;
        }
        try {
            return new SimpleDateFormat(format).parse(string);
        } catch (ParseException e) {
            log.error("时间转换异常,{}",string);
        }
        return null;
    }

    public static Date parase(String string, String format) throws ParseException {
        if (StringUtils.isEmpty(string)) {
            return null;
        }

        return new SimpleDateFormat(format).parse(string);
    }

    public static Date startOfDay(Date date) {
        LocalDate localDate = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        LocalDateTime localDateTime = LocalDateTime.of(localDate, LocalTime.MIN);
        return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
    }

    public static Date endOfDay(Date date) {
        LocalDate localDate = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        LocalDateTime localDateTime = LocalDateTime.of(localDate, LocalTime.MAX);
        return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
    }


    /**
     * 获取当前系统时间
     *
     * @return
     */
    public static Date getSysDate() {
        Calendar calender = Calendar.getInstance();
        return calender.getTime();
    }



    /**
     * convert date to string with format,the format like these:
     @param dt date of to be formated
     @param format string,such as: "yyyy-MM-dd HH:mm:ss"
     @return: success return string datetime, otherwise return null
     */
    public static String formatDateTime(Date dt, String format){
        if (dt==null) {
            return null;
        }

        String str = null;
        try{
            DateFormat fmt = new SimpleDateFormat(format);
            str = fmt.format(dt);
            if (str.compareTo("1899-12-30")<=0 && format.compareTo("yyyy")>0) {
                str = null;
            }
        }catch(Exception e){
            log.error(e.toString(), e);
        }
        return str;
    }

    public static String formatDateTime(Date dt, String format, Locale locale){
        if (dt==null) {
            return null;
        }

        String str = null;
        try{
            DateFormat fmt = new SimpleDateFormat(format,locale);
            str = fmt.format(dt);
            if (str.compareTo("1899-12-30")<=0 && format.compareTo("yyyy")>0) {
                str = null;
            }
        }catch(Exception e){
            log.error(e.toString(), e);
        }
        return str;
    }

    /**
     * format datetime to yyyy-MM-dd
     * @param date to format date
     * @return null when exception throw or return date string
     */
    public static String dateToDateString(Date date) {
        return formatDateTime(date,"yyyy-MM-dd");
    }

    public static Integer dateToDateInteger(Date date) {
        return Integer.parseInt(formatDateTime(date,"yyyyMMdd"));
    }

    /**
     * format datetime to HH:mm:ss
     * @param date to format date
     * @return null when exception throw or return time string
     */
    public static String dateToTimeString(Date date) {
        return formatDateTime(date,"HH:mm:ss");
    }

    /**
     * format datetime to yyyy-MM-dd HH:mm:ss
     * @param date to format date
     * @return null when exception throw or return time string
     */
    public static String dateToDateTimeString(Date date) {
        return formatDateTime(date,"yyyy-MM-dd HH:mm:ss");
    }

    /**
     * convert Date to long value
     * @param date
     * @return yyyyMMddHHmmss long value
     */
    public static long datetimeToInt(Date date){
        String value = formatDateTime(date,"yyyyMMddHHmmss");
        return Long.parseLong(value);
    }

    /**
     * convert Date to long value
     * @param date
     * @return unix time
     */
    public static long datetimeToUnixTime(Date date){
        if (date==null) {
            return 0;
        }

        return date.getTime()/1000;
    }

    /**
     * convert unixTime to Date
     * @param unix time
     * @return date
     */
    public static Date datetimeToUnixTime(long unix){
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String d = format.format(unix);
        Date ret;
        try {
            ret = format.parse(d);
            return ret;
        } catch (ParseException e) {
            log.error(e.toString(), e);
        }
        return null;
    }

    /**
     * convert yyyyMMdd date to yyyy-MM-dd date
     * @param iDate format of yyyyMMdd integer value
     * @return null if invalid nDate, or return yyyy-MM-dd string
     */
    public static String formatNumericDate(int iDate){
        String tmp = Integer.toString(iDate);
        String ret = null;
        if (tmp.length()==8){
            ret = tmp.substring(0, 4)+"-"+tmp.substring(4,6)+"-"+tmp.substring(6,8);
        }
        return ret;
    }


    /**
     * convert yyMMddHHNNSS date to yyyy-MM-dd HH:NN:SS date
     * @param sDate format of yyyyMMdd integer value
     * @return null if invalid nDate, or return yyyy-MM-dd HH:NN:SS string
     */
    public static String formatNumericDatetime(String sDate){
        String ret = null;
        if (sDate.length()==12){
            ret = "20"+sDate.substring(0, 2)+"-"+sDate.substring(2,4)+"-"+sDate.substring(4,6)+" "+
                    sDate.substring(6,8)+":"+sDate.substring(8,10)+":"+sDate.substring(10,12);
        }
        return ret;
    }

    /**
     * to inc time by indicating field with amount value
     * @param dt Date to add time
     * @param field to indicate which part to increase
     * @param amount date's field to add amount
     * @return new Date if successful, otherwise return null
     */
    private static Date incTime(Date dt, int field, int amount){
        if (dt==null) {
            return null;
        }

        try{
            Calendar cd = Calendar.getInstance();
            cd.setTime(dt);
            cd.add(field, amount);
            return cd.getTime();
        }catch(Exception e){
            log.error(e.toString(), e);
        }
        return null;
    }

    /**
     * to increse years to Date
     * @param dt Date to increse year
     * @param years number of year to increase
     * @return incresed Date if successful, otherwise return null
     */
    public static Date incYear(Date dt, int years){
        return incTime(dt,Calendar.YEAR, years);
    }

    /**
     * to increse months to Date
     * @param dt Date to increse month
     * @param months number of month to increase
     * @return incresed Date if successful, otherwise return null
     */
    public static Date incMonth(Date dt, int months){
        return incTime(dt,Calendar.MONTH, months);
    }

    /**
     * to increse days to Date
     * @param dt Date to increse day
     * @param days number of day to increase
     * @return incresed Date if successful, otherwise return null
     */
    public static Date incDay(Date dt, int days){
        return incTime(dt,Calendar.DATE, days);
    }

    /**
     * to increse hours to Date
     * @param dt Date to increse hour
     * @param hours number of hours to increase
     * @return incresed Date if successful, otherwise return null
     */
    public static Date incHour(Date dt, int hours){
        return incTime(dt,Calendar.HOUR, hours);
    }

    /**
     * to increse minutes to Date
     * @param dt Date to increse minute
     * @param minutes number of minutes to increase
     * @return incresed Date if successful, otherwise return null
     */
    public static Date incMinute(Date dt, int minutes){
        return incTime(dt,Calendar.MINUTE, minutes);
    }

    /**
     * to increse seconds to Date
     * @param dt Date to increse second
     * @param seconds number of seconds to increase
     * @return incresed Date if successful, otherwise return null
     */
    public static Date incSecond(Date dt, int seconds){
        return incTime(dt,Calendar.SECOND, seconds);
    }

    /**
     * to calculate seconds between now and then
     * @param now
     * @param then
     * @return seconds between now and then
     */
    public static int secondsBetween(Date now, Date then){
        return (int) Math.abs(((now.getTime()-then.getTime())/1000));
    }

    /**
     * to calculate minutes between now and then
     * @param now
     * @param then
     * @return
     */
    public static int minutesBetween(Date now, Date then){
        return secondsBetween(now, then)/60;
    }

    public static int daysBetween(Date now, Date then){
        return minutesBetween(now, then)/(60*24);
    }

    /**
     * string to datetime
     * @param str it's format is that: "yyyy-MM-dd HH:mm:ss" or "yyyy-MM-ddTHH:mm:ss"
     * @return
     */
    public static Date strToDateTime(String str){
        if (StringUtils.isBlank(str)) {return null;}
        str = str.replace("T", " ");
        if (str.length()==16) {str += ":00";}
        return strToDateTime(str,"yyyy-MM-dd HH:mm:ss");
    }

    /**
     * string to datetime
     * @param str
     * @return
     */
    public static Date strToDateTime(String str,String fmt){

        SimpleDateFormat format = new SimpleDateFormat(fmt);
        Date date = null;
        try{
            date = format.parse(str);
        }catch(ParseException e){
            log.error(e.toString(), e);
        }
        return date;
    }

    /**
     * string to date
     * @param str it's format is that: "yyyy-MM-dd"
     * @return
     */
    public static Date strToDate(String str){
        if (StringUtils.isBlank(str)) {return null;}
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
        Date date = null;
        try{
            date = format.parse(str);
        }catch(ParseException e){
            log.error(e.toString(), e);
        }
        return date;
    }

    /**
     * to get first day of indicate date
     * @param date
     * @return
     * by @author lms 2017.03.08
     */
    public static Date startOfTheMonth(Date date){
        Calendar cd = Calendar.getInstance();
        cd.setTime(date);
        cd.set(Calendar.DATE, 1);
        return cd.getTime();
    }


    /**
     * to get last day of indicate date
     * @param date
     * @return
     * by @author lms 2017.03.08
     */
    public static Date endOfTheMonth(Date date){
        Calendar cd = Calendar.getInstance();
        cd.setTime(date);
        cd.set(Calendar.DATE, 1);
        cd.roll(Calendar.DATE, -1);
        return cd.getTime();
    }

    /**
     * to truncate Date's time, such as "2017-3-8 15:45:12"=>"2017-3-8 00:00:00"
     * @param date
     * @return
     * by @author lms 2017.03.08
     */
    public static Date truncateTime(Date date){
        Calendar cd = Calendar.getInstance();
        cd.setTime(date);
        cd.set(Calendar.HOUR_OF_DAY, 0);
        cd.set(Calendar.MINUTE, 0);
        cd.set(Calendar.SECOND, 0);
        cd.set(Calendar.MILLISECOND, 0);

        return cd.getTime();
    }

    /**
     * to get the month days of indicating date
     * @param date
     * @return
     * by @author lms 2017.05.25
     */
    public static int daysOfTheMonth(Date date){
        Calendar cd = Calendar.getInstance();
        cd.setTime(date);
        cd.set(Calendar.DATE, 1);
        cd.roll(Calendar.DATE, -1);
        return cd.get(Calendar.DATE);
    }

    /**
     * to get the day of indicating date
     * @param date
     * @return
     * by @author lms 2017.05.25
     */
    public static int dayOf(Date date){
        Calendar cd = Calendar.getInstance();
        cd.setTime(date);
        return cd.get(Calendar.DATE);
    }

    /**
     * to get month of indicating date
     * @param date
     * @return 1~12
     * by @author lms 2017.05.25
     */
    public static int monthOf(Date date){
        Calendar cd = Calendar.getInstance();
        cd.setTime(date);
        return cd.get(Calendar.MONTH)+1;
    }

    /**
     * to get year of indicating date
     * @param date
     * @return
     * by @author lms 2017.05.25
     */
    public static int yearOf(Date date){
        Calendar cd = Calendar.getInstance();
        cd.setTime(date);
        return cd.get(Calendar.YEAR);
    }

    //n天前的初始时间
    public static long getDayAgoFirstTime(int n) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, 0 - n);
        cal.set(Calendar.HOUR_OF_DAY,0);
        cal.set(Calendar.MINUTE,0);
        cal.set(Calendar.SECOND,0);
        cal.set(Calendar.MILLISECOND,0);
        return cal.getTimeInMillis();
    }

    //n个月的初始时间
    public static long getMonAgoFirstTime(int n) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        if(n > 0) {
            cal.add(Calendar.MONTH,0 - n);
        }
        cal.set(Calendar.DAY_OF_MONTH, 1);
        cal.set(Calendar.HOUR_OF_DAY,0);
        cal.set(Calendar.MINUTE,0);
        cal.set(Calendar.SECOND,0);
        cal.set(Calendar.MILLISECOND,0);
        return cal.getTime().getTime();
    }

    //n分钟前的初始时间
    public static long getMinAgoFirstTime(int n) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        if(n > 0) {
            cal.add(Calendar.MINUTE,0 - n);
        }
        cal.set(Calendar.SECOND,0);
        cal.set(Calendar.MILLISECOND,0);
        return cal.getTime().getTime();
    }

    /**
     * 获取分钟戳 如201904201427
     * @param date
     * @return
     */
    public static long getMinuteStamp(Date date) {
        String minStr = DateUtil.formatDateTime(date, "yyyyMMddHHmm");
        return Long.parseLong(minStr);
    }

    /**
     * 获取小时戳 如2019042014
     * @param date
     * @return
     */
    public static int getHourStamp(Date date) {
        String hourStr = DateUtil.formatDateTime(date, "yyyyMMddHH");
        return Integer.parseInt(hourStr);
    }

    /**
     * 获取日期戳 如20190420
     * @param date
     * @return
     */
    public static int getDayStamp(Date date) {
        String hourStr = DateUtil.formatDateTime(date, "yyyyMMdd");
        return Integer.parseInt(hourStr);
    }

    /**
     * 获取月份戳 如201904
     * @param date
     * @return
     */
    public static int getMonthStamp(Date date) {
        String hourStr = DateUtil.formatDateTime(date, "yyyyMM");
        return Integer.parseInt(hourStr);
    }

    public static void main(String args[]){
        String str = "2018-06-18 18:00";
        System.out.println(DateUtil.strToDateTime(str));
    }

    /**
     * 方法描述:获取到检时的年龄
     * 年龄默认0，到检日期不为空，先根据身份证获取生日年龄，如果身份证为空，根据生日获取
     * idType 证件类型 参数已不再继续使用（原因：数据传输可能错误）
     * @param regDate 到检日志
     * @param examUserIdcard 证件号
     * @param examUserBirth 出生日期
     * @return  java.lang.Integer
     * @author  wenyue.gao@ikang.com
     * @date    2022/2/21 16:14
     */
    public static Integer getAge(Date regDate, String examUserIdcard, String examUserBirth) {
        int age = 0;
        if (null != regDate) {
            if (!org.springframework.util.StringUtils.isEmpty(examUserIdcard) && examUserIdcard.length() == 18) {
                DateTime regDateTime = cn.hutool.core.date.DateUtil.parse(cn.hutool.core.date.DateUtil.format(regDate, "yyyy-MM-dd"));
                try {
                    age = IdcardUtil.getAgeByIdCard(examUserIdcard, regDateTime);
                } catch (Exception e) {
                    log.error("通过身份证获取年龄异常,IdCard:{},exception:{}", examUserIdcard, e);
                }
            } else {
                if (!org.springframework.util.StringUtils.isEmpty(examUserBirth)) {
                    DateTime birthDate = cn.hutool.core.date.DateUtil.parse(examUserBirth.replace("-", ""), "yyyyMMdd");
                    age = cn.hutool.core.date.DateUtil.age(birthDate, regDate);
                }
            }
        }
        return age;
    }

    public static Date addOneDay(Date sDate){
        Date date ;
        try {
//            Format f = new SimpleDateFormat("yyyy-MM-dd");
            Calendar c = Calendar.getInstance();
            c.setTime(sDate);
            c.add(Calendar.DAY_OF_MONTH, 1);
            date = c.getTime();
            return date;
        } catch (Exception e) {
            log.info("日期转换异常：{}",e);
        }
        return sDate;
    }
    
    /**
     * LocalDate转Date
     * @param localDate
     * @return
     */
    public static Date localDate2Date(LocalDate localDate) {
        if (null == localDate) {
            return null;
        }
        ZonedDateTime zonedDateTime = localDate.atStartOfDay(ZoneId.systemDefault());
        return Date.from(zonedDateTime.toInstant());
    }

    /**
     * Date转LocalDate
     * @param date
     */
    public static LocalDate date2LocalDate(Date date) {
        if(null == date) {
            return null;
        }
        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
    }
    
    /**
     * dateString转换成LocalDateTime yyyy-MM-dd HH:mm:ss
     *
     * @param dateString   日期字符串
     */
    public static LocalDateTime dateStringToLocalDateTime(String dateString) {
        return LocalDateTime.parse(dateString, DateUtil.DTF_DATE_FORMAT_DATETIME);
    }

    /**
     * dateString转换成LocalDateTime yyyy-MM-dd
     *
     * @param dateString   日期字符串
     */
    public static LocalDateTime dateStringToLocalDateTimeNotHaveHour(String dateString) {
        return LocalDateTime.parse(dateString, DateUtil.DTF_DATE_FORMAT_DATETIME_YEAR_MONTH_DAY);
    }
}
```



### CalculateUtil数字计算工具类

```java
import cn.hutool.core.util.NumberUtil;
import com.ikang.idata.common.utils.StringUtil;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;

import static java.math.BigDecimal.ZERO;


/**
 * @description 计算
 * @date 2022/3/10 16:31
 */
public class CalculateUtil {
    /**
     * @param v1 除数
     * @param v2 被除数22
     * @date: 2022/3/10 16:32
     */
    public static BigDecimal div(String v1, String v2) {
        if (!NumberUtil.isNumber(v1) ||
                !NumberUtil.isNumber(v2) ||
                0 == ZERO.compareTo(new BigDecimal(v1)) ||
                0 == ZERO.compareTo(new BigDecimal(v2))) {
            return ZERO;
        }
        return NumberUtil.div(new BigDecimal(v1).toPlainString(), new BigDecimal(v2).toPlainString());
    }

    public static BigDecimal div(BigDecimal v1, BigDecimal v2) {
        if (Objects.isNull(v1) ||
                Objects.isNull(v2) ||
                0 == ZERO.compareTo(v1) ||
                0 == ZERO.compareTo(v2)) {
            return ZERO;
        }
        return NumberUtil.div(v1.toPlainString(), v2.toPlainString());
    }


    public static BigDecimal div(BigDecimal v1, BigDecimal v2, int scale) {

        if (Objects.isNull(v1) ||
                Objects.isNull(v2) ||
                0 == ZERO.compareTo(v1) ||
                0 == ZERO.compareTo(v2)) {
            return ZERO;
        }
        return NumberUtil.div(v1.toPlainString(), v2.toPlainString(), scale);
    }

    /**
     * @param v1 除数
     * @param v2 被除数
     * @date: 2022/3/10 16:32
     */
    public static BigDecimal div(String v1, String v2, int scale) {
        if (!NumberUtil.isNumber(v1) ||
                !NumberUtil.isNumber(v2) ||
                0 == ZERO.compareTo(new BigDecimal(v1)) ||
                0 == ZERO.compareTo(new BigDecimal(v2))) {
            return ZERO;
        }
        return NumberUtil.div(new BigDecimal(v1).toPlainString(), new BigDecimal(v2).toPlainString(), scale);
    }

    /**
     * 计算增长率
     *
     * @param v1 除数   必须是数字字符串
     * @param v2 被除数 必须是数字字符串
     * @date: 2022/3/23 17:16
     */
    public static BigDecimal calculateGrowthRate4(BigDecimal v1, BigDecimal v2) {
        if (Objects.isNull(v1) || Objects.isNull(v2)) {
            return null;
        }
        if (0 != ZERO.compareTo(v1) && 0 == ZERO.compareTo(v2)) {
            return new BigDecimal("1");
        }
        v1 = new BigDecimal(v1.toPlainString());
        v2 = new BigDecimal(v2.toPlainString());
        return CalculateUtil.div(NumberUtil.sub(v1.toPlainString(), v2.toPlainString()).toString(), v2.toString(), 4);
    }

    public static void main(String[] args) {
        BigDecimal bigDecimal = calculateGrowthRate4(new BigDecimal("1144"), new BigDecimal("1114"));
        System.out.println("bigDecimal = " + bigDecimal);
    }

    /**
     * 计算加项人次,金额占比
     *
     * @param v1 除数   必须是数字字符串
     * @param v2 被除数 必须是数字字符串
     * @date: 2023/5/8 15:16
     */
    public static BigDecimal calculateAdditionRatio4(BigDecimal v1, BigDecimal v2) {
        if (Objects.isNull(v1) || Objects.isNull(v2)) {
            return null;
        }
        if (0 != ZERO.compareTo(v1) && 0 == ZERO.compareTo(v2)) {
            return new BigDecimal("1");
        }
        v1 = new BigDecimal(v1.toPlainString());
        v2 = new BigDecimal(v2.toPlainString());
        return CalculateUtil.div(v1.toString(), v2.toString(), 4);
    }

    /**
     * 计算加项人次,金额占比
     *
     * @param v1 除数   必须是数字字符串
     * @param v2 被除数 必须是数字字符串
     * @date: 2023/5/12 17:14
     */
    public static BigDecimal calculateAdditionRatio2(BigDecimal v1, BigDecimal v2) {
        if (Objects.isNull(v1) || Objects.isNull(v2)) {
            return null;
        }
        if (0 != ZERO.compareTo(v1) && 0 == ZERO.compareTo(v2)) {
            return new BigDecimal("1");
        }
        v1 = new BigDecimal(v1.toPlainString());
        v2 = new BigDecimal(v2.toPlainString());
        return CalculateUtil.div(v1.toString(), v2.toString(), 2);
    }


    /**
     * 签单分析  计算人均签单个数及人均签单金额
     *
     * @param v1 除数   必须是数字字符串
     * @param v2 被除数 必须是数字字符串
     * @date: 2023/7/20 15:25
     */
    public static BigDecimal perCapital2(BigDecimal v1, BigDecimal v2) {
        if (Objects.isNull(v1) || Objects.isNull(v2) || 0 == ZERO.compareTo(v2)) {
            return null;
        }
        if (0 != ZERO.compareTo(v1) && 0 == ZERO.compareTo(v2)) {
            return new BigDecimal("1");
        }
        v1 = new BigDecimal(v1.toPlainString());
        v2 = new BigDecimal(v2.toPlainString());
        return CalculateUtil.div(v1.toString(), v2.toString(), 2);
    }

    /**
     * 位数修改
     *
     * @param numStr 数字字符串
     * @param scale  精度
     * @date: 2022/3/25 14:48
     */
    public static String round(String numStr, int scale) {
        return StringUtil.isEmpty(numStr) ? numStr : NumberUtil.round(numStr, scale).toString();
    }

    /**
     * 位数修改
     *
     * @param decimal 数字
     * @param scale   精度
     * @date: 2022/3/26 17:51
     */
    public static BigDecimal round(BigDecimal decimal, int scale) {
        return Objects.isNull(decimal) ? decimal : decimal.setScale(scale, RoundingMode.HALF_UP);
    }

    /**
     * 增长率计算
     *
     * @param v1 除数   必须是数字字符串
     * @param v2 被除数 必须是数字字符串
     * @return 增长率
     * @date 2024/3/6 17:58
     */
    public static BigDecimal synchronousCalculation(String v1, String v2) {
        if (!NumberUtil.isNumber(v1) || !NumberUtil.isNumber(v2)) {
            return ZERO;
        }
        BigDecimal num1 = new BigDecimal(v1).stripTrailingZeros();
        BigDecimal num2 = new BigDecimal(v2).stripTrailingZeros();
        if (num1.equals(num2)) {
            return ZERO;
        }
        if (!ZERO.equals(num1) && ZERO.equals(num2)) {
            return new BigDecimal("1");
        }
        return CalculateUtil.div(NumberUtil.sub(num1, num2).toString(), v2, 4);
    }
}
```

### DoubleUtils Double数值计算

```java
import cn.hutool.core.util.NumberUtil;
import com.ikang.idata.common.entity.vo.AreaWorkTableCheckVO;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.DecimalFormat;

import static com.ikang.idata.common.consts.MagicConst.*;

/**
 * DoubleUtil.
 *
 * @author zj.
 *         Created on 2018/9/19 0019.
 */
public class DoubleUtils {
    // 默认除法运算精度
    private static final Integer DEF_DIV_SCALE = 6;



    /**
     * 提供精确的加法运算（保留2位小数）。
     *
     * @param value1 被加数
     * @param value2 加数
     * @return 两个参数的和.
     */
    public static Double add(Double value1, Double value2) {
        BigDecimal b1 = new BigDecimal(Double.toString(value1));
        BigDecimal b2 = new BigDecimal(Double.toString(value2));
        BigDecimal sum = b1.add(b2);
        return sum.setScale(DEF_DIV_SCALE, BigDecimal.ROUND_HALF_UP).doubleValue();
    }

    /**
     * 提供精确的减法运算。
     *
     * @param value1 被减数
     * @param value2 减数
    * @return 两个参数的差
     */
    public static double sub(Double value1, Double value2) {
        return sub(value1, value2, DEF_DIV_SCALE);
    }

    /**
     * 提供精确的减法运算。
     *
     * @param value1 被减数
     * @param value2 减数
     * @param scale 保留位数
     * @return 两个参数的差
     */
    public static double sub(Double value1, Double value2, Integer scale) {
        BigDecimal b1 = new BigDecimal(Double.toString(value1));
        BigDecimal b2 = new BigDecimal(Double.toString(value2));
        return b1.subtract(b2).setScale(scale, RoundingMode.HALF_UP).doubleValue();
    }



    public static BigDecimal subtract4(String value1, String value2) {
        value1 = StringUtil.isEmpty(value1) || "null".equals(value1) || "0.0".equals(value1) ||  "0.00".equals(value1) ? "0" : value1;
        value2 = StringUtil.isEmpty(value2) || "null".equals(value2) || "0.0".equals(value2)  || "0.00".equals(value2) ? "0" : value2;
        BigDecimal b1 = new BigDecimal(value1);
        BigDecimal b2 = new BigDecimal(value2);
        return b1.subtract(b2).setScale(4, RoundingMode.HALF_UP);
    }

    /**
     * 提供精确的减法运算。
     *
     * @param value1 被减数
     * @param value2 减数
     * @param scale 保留位数
     * @return 两个参数的差
     */

    public static BigDecimal subtract(String value1, String value2, Integer scale) {
        if (scale < 0) {
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        value1 = StringUtil.isEmpty(value1) || "null".equals(value1) || "0.0".equals(value1) ||  "0.00".equals(value1) ? "0" : value1;
        value2 = StringUtil.isEmpty(value2) || "null".equals(value2) || "0.0".equals(value2)  || "0.00".equals(value2) ? "0" : value2;
        BigDecimal b1 = new BigDecimal(value1);
        BigDecimal b2 = new BigDecimal(value2);
        return b1.subtract(b2).setScale(scale, RoundingMode.HALF_UP);
    }


    public static BigDecimal add(String value1, String value2) {
        value1 = StringUtil.isEmpty(value1) || "null".equals(value1) || "0.0".equals(value1) ||  "0.00".equals(value1) ? "0" : value1;
        value2 = StringUtil.isEmpty(value2) || "null".equals(value2) || "0.0".equals(value2)  || "0.00".equals(value2) ? "0" : value2;
        BigDecimal b1 = new BigDecimal(value1);
        BigDecimal b2 = new BigDecimal(value2);
        BigDecimal sum = b1.add(b2);
        return sum.setScale(DEF_DIV_SCALE, BigDecimal.ROUND_HALF_UP);
    }

    public static BigDecimal subtract( BigDecimal b1, BigDecimal b2, Integer scale) {
        if (scale < 0) {
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        if (null == b1) {
            b1 = new BigDecimal(0);
        }
        if (null == b2) {
            b2 = new BigDecimal(0);
        }
        return b1.subtract(b2).setScale(scale, RoundingMode.HALF_UP);
    }


    public static String sub(String value1, String value2, Integer scale) {
        BigDecimal b1 = new BigDecimal(value1);
        BigDecimal b2 = new BigDecimal(value2);
        return b1.subtract(b2).setScale(scale, RoundingMode.HALF_UP).toString();
    }

    /**
     * 提供精确的乘法运算。
     *
     * @param value1 被乘数
     * @param value2 乘数
     * @return 两个参数的积
     */
    public static Double mul(Double value1, Double value2) {
        return mul(value1, value2, DEF_DIV_SCALE);
    }

    /**
     * 提供精确的乘法运算。
     *
     * @param value1 被乘数
     * @param value2 乘数
     * @param scale 保留位数
     * @return 两个参数的积
     */
    public static Double mul(Double value1, Double value2, Integer scale) {
        BigDecimal b1 = new BigDecimal(Double.toString(value1));
        BigDecimal b2 = new BigDecimal(Double.toString(value2));
        return b1.multiply(b2).setScale(scale, RoundingMode.HALF_UP).doubleValue();
    }

    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时， 精确到小数点以后10位，以后的数字四舍五入。
     *
     * @param dividend 被除数
     * @param divisor  除数
     * @return 两个参数的商
     */
    public static Double divide(Double dividend, Double divisor) {
        return divide(dividend, divisor, DEF_DIV_SCALE);
    }

    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时， 精确到小数点以后10位，以后的数字四舍五入。
     *
     * @param dividend 被除数
     * @param divisor  除数
     * @return 两个参数的商
     */
    public static Double divide(Integer dividend, Integer divisor) {
        return divide(dividend, divisor, DEF_DIV_SCALE);
    }

    /**
     * 提供（相对）精确的除法运算。 当发生除不尽的情况时，由scale参数指定精度，以后的数字四舍五入。
     *
     * @param dividend 被除数
     * @param divisor  除数
     * @param scale    表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static Double divide(Integer dividend, Integer divisor, Integer scale) {
        Integer temp = 0;
        if (null == dividend || null == divisor || temp.equals(divisor)) {
            return 0d;
        }
        if (scale < 0) {
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        BigDecimal b1 = new BigDecimal(Double.toString(dividend));
        BigDecimal b2 = new BigDecimal(Double.toString(divisor));
        return b1.divide(b2, scale, RoundingMode.HALF_UP).doubleValue();
    }
    /**
     * 提供（相对）精确的除法运算。 当发生除不尽的情况时，由scale参数指定精度，以后的数字四舍五入。
     *
     * @param dividend 被除数
     * @param divisor  除数
     * @return 两个参数的商
     */
    public static BigDecimal divide4(String dividend, String divisor) {
        dividend = StringUtil.isEmpty(dividend) || "null".equals(dividend) || "0.0".equals(dividend) ||  "0.00".equals(dividend) ? "0" : dividend;
        divisor = StringUtil.isEmpty(divisor) || "null".equals(divisor) || "0.0".equals(divisor)  || "0.00".equals(divisor) ? "0" : divisor;

        if (STR_0.equals(divisor) && !STR_0.equals(dividend)) {
            return new BigDecimal(1);
        }
        if (STR_0.equals(divisor) && NumberUtil.isNumber(dividend)) {
            return null;
        }
        BigDecimal b1 = new BigDecimal(dividend);
        BigDecimal b2 = new BigDecimal(divisor);
        return b1.divide(b2, 4, RoundingMode.HALF_UP);
    }


    /**
     * 方法描述:
     * 当期：不为0，同期为0，+100%
     * 当期：0，同期不为0，-100%
     * 当期：0，同期0，持平增长0%
     * @param dividend
     * @param divisor 
     * @return  java.math.BigDecimal
     * @author  wenyue.gao@ikang.com
     * @date    2022/3/25 11:14
     */
    public static BigDecimal divide4Rate(BigDecimal dividend, BigDecimal divisor) {
       //  当期：不为0，同期为0，+100%
        if ((null != dividend || INT_0 != dividend.intValue()) && (null == divisor || INT_0 == divisor.intValue())){
            return new BigDecimal(1);
        }
        // 当期：0，同期不为0，-100%
        if ((null == dividend || INT_0 == dividend.intValue()) && (null != divisor || INT_0 != divisor.intValue())){
            return new BigDecimal(-1);
        }

        // 0，同期0，持平增长0%
        if ((null == dividend || INT_0 == dividend.intValue()) && (null == divisor || INT_0 == divisor.intValue())){
            return new BigDecimal(0);
        }
        return dividend.divide(divisor, 4, RoundingMode.HALF_UP);
    }



    /**
     * 提供（相对）精确的除法运算。 当发生除不尽的情况时，由scale参数指定精度，以后的数字四舍五入。
     *
     * @param dividend 被除数
     * @param divisor  除数
     * @param scale    表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static Double divide(Double dividend, Double divisor, Integer scale) {
        if (scale < 0) {
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        BigDecimal b1 = new BigDecimal(Double.toString(dividend));
        BigDecimal b2 = new BigDecimal(Double.toString(divisor));
        return b1.divide(b2, scale, RoundingMode.HALF_UP).doubleValue();
    }

    public static BigDecimal divide(String dividend, String divisor, Integer scale) {
        if (scale < 0) {
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        dividend = StringUtil.isEmpty(dividend) || "null".equals(dividend) || "0.0".equals(dividend)  ||  "0.00".equals(dividend) ? "0" : dividend;
        divisor = StringUtil.isEmpty(divisor) || "null".equals(divisor) || "0.0".equals(divisor)  ||  "0.00".equals(divisor) ? "0" : divisor;
        if (STR_0.equals(divisor) && NumberUtil.isNumber(dividend)) {
            return null;
        }
        BigDecimal b1 = new BigDecimal(dividend);
        BigDecimal b2 = new BigDecimal(divisor);
        return b1.divide(b2, scale, RoundingMode.HALF_UP);
    }


    /**
     * 提供指定数值的（精确）小数位四舍五入处理。
     *
     * @param value 需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double value,int scale){
        if(scale<0){
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        BigDecimal b = new BigDecimal(Double.toString(value));
        BigDecimal one = new BigDecimal("1");
        return b.divide(one,scale, RoundingMode.HALF_UP).doubleValue();
    }

    public static void main(String[] args) {
        AreaWorkTableCheckVO checkVO = new AreaWorkTableCheckVO();
        checkVO.setCheckIncome(new BigDecimal(1.222));
        System.out.println(checkVO.getCheckIncome());

        BigDecimal bigDecimal = divide4("111", "0");
        System.out.println(bigDecimal);
    }
}
```





### PhoneUtil校验手机号工具类

```java
import cn.hutool.core.lang.PatternPool;
import cn.hutool.core.lang.Validator;
import cn.hutool.core.util.StrUtil;

import java.util.regex.Pattern;

public class PhoneUtil {

    /**
     * 座机号码
     */
    private static final Pattern TEL = Pattern.compile("0\\d{2,3}-[1-9]\\d{6,7}");

    /**
     * 验证是否为手机号码（中国）
     *
     * @param value 值
     * @return 是否为手机号码（中国）
     * @since 5.3.11
     */
    public static boolean isMobile(CharSequence value) {
        return Validator.isMatchRegex(PatternPool.MOBILE, value);
    }

    public static void main(String[] args) {
        boolean mobile = isMobile("12312321323");
        System.out.println(mobile);
    }

    /**
     * 验证是否为座机号码（中国）
     *
     * @param value 值
     * @return 是否为座机号码（中国）
     * @since 5.3.11
     */
    public static boolean isTel(CharSequence value) {
        return Validator.isMatchRegex(TEL, value);
    }

    /**
     * 验证是否为座机号码+手机号码（中国）
     *
     * @param value 值
     * @return 是否为座机号码+手机号码（中国）
     * @since 5.3.11
     */
    public static boolean isPhone(CharSequence value) {
        return isMobile(value) || isTel(value);
    }

    /**
     * 隐藏手机号前7位  替换字符为"*"
     * 栗子
     *
     * @param phone 手机号码
     * @return 替换后的字符串
     * @since 5.3.11
     */
    public static CharSequence hideBefore(CharSequence phone) {
        return StrUtil.hide(phone, 0, 7);
    }

    /**
     * 隐藏手机号中间4位  替换字符为"*"
     *
     * @param phone 手机号码
     * @return 替换后的字符串
     * @since 5.3.11
     */
    public static CharSequence hideBetween(CharSequence phone) {
        return StrUtil.hide(phone, 3, 7);
    }

    /**
     * 隐藏手机号最后4位  替换字符为"*"
     *
     * @param phone 手机号码
     * @return 替换后的字符串
     * @since 5.3.11
     */
    public static CharSequence hideAfter(CharSequence phone) {
        return StrUtil.hide(phone, 7, 11);
    }

    /**
     * 获取手机号前3位
     *
     * @param phone 手机号码
     * @return 手机号前3位
     * @since 5.3.11
     */
    public static CharSequence subBefore(CharSequence phone) {
        return StrUtil.sub(phone, 0, 3);
    }

    /**
     * 获取手机号中间4位
     *
     * @param phone 手机号码
     * @return 手机号中间4位
     * @since 5.3.11
     */
    public static CharSequence subBetween(CharSequence phone) {
        return StrUtil.sub(phone, 3, 7);
    }

    /**
     * 获取手机号后4位
     *
     * @param phone 手机号码
     * @return 手机号后4位
     * @since 5.3.11
     */
    public static CharSequence subAfter(CharSequence phone) {
        return StrUtil.sub(phone, 7, 11);
    }

}
```

### PinyinUtil拼音工具类

```java
public class PinyinUtil {
    /**
     * @param chinese 中文
     * @return 首字符 任宝鑫=>rbx
     * @author <a href="mailto:hao.liu-ext@ikang.com">hao.liu</a>
     * @date: 2022/2/21 16:59
     */
    public static String getFirstUpperCase(String chinese) {
        return cn.hutool.extra.pinyin.PinyinUtil.getFirstLetter(chinese, ",").split(",")[0].toUpperCase();
    }

}
```



### ReflectUtils反射工具类

```java
import org.springframework.util.ReflectionUtils;

import java.lang.reflect.Method;
import java.util.Objects;
import java.util.stream.Stream;

/**
 * @date: 2022/2/18 14:19
 */
public class ReflectUtils {

    /**
     * 根据 服务名称 ，方法名 反射调用  spring bean 中的 方法
     *
     * @param serviceName 服务名
     * @param methodName  方法名
     * @param params      参数
     * @return 执行结果
     * @throws Exception 异常
     * @date: 2022/2/18 14:20
     */
    public static Object springInvokeMethod(String serviceName, String methodName, Object... params) throws Exception {
        Object service = ContextUtil.getBean(serviceName);
        return springInvokeMethod(service, methodName, params);
    }

    /**
     * @param serviceClz bean的class
     * @param methodName 方法名称
     * @param params     参数名称
     * @param <T>        返回类型
     * @return 返回结果
     * @date: 2022/2/18 15:11
     */
    public static <T> T springInvokeMethod(Class<?> serviceClz, String methodName, Object... params) {
        Object bean = ContextUtil.getBean(serviceClz);
        return springInvokeMethod(bean, methodName, params);
    }


    /**
     * @param service    服务
     * @param methodName 方法名称
     * @param params     参数名称
     * @param <T>        返回类型
     * @return 返回结果
     * @date: 2022/2/18 15:11
     */
    public static <T> T springInvokeMethod(Object service, String methodName, Object... params) {
        // 找到方法
        Method method;
        if (Objects.isNull(params)) {
            method = ReflectionUtils.findMethod(service.getClass(), methodName);
            // 执行方法
            assert method != null;
            return (T) ReflectionUtils.invokeMethod(method, service);
        } else {
            method = ReflectionUtils.findMethod(service.getClass(), methodName, Stream.of(params).map(Object::getClass).toArray(Class[]::new));
            assert method != null;
            return (T) ReflectionUtils.invokeMethod(method, service, params);
        }
    }

}
```





### 魔法字符

#### MagicConst

```java
package com.ikang.bprom.common.constant;

import cn.hutool.core.text.StrPool;
import java.util.regex.Pattern;

public interface MagicConst extends StrPool {
    String SIGN = "sign";
    String TIMESTAMP = "timestamp";
    String APPID = "appId";
    String MESSAGE = "message";
    String CACHE_NAME_SPACE = "op2c";
    String IP_255 = "(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
    /**
     * IpUtil
     */
    Pattern PATTERN = Pattern.compile("^(?:" + IP_255 + "\\.){3}" + IP_255 + "$");
    /**
     * IpUtil
     */
    String IP = "10.0.0.0";
    String X_FORWARDED_FOR = "x-forwarded-for";
    String IP1 = "10.255.255.255";
    String IP2 = "172.16.0.0";
    String IP3 = "172.31.255.255";
    String IP4 = "192.168.0.0";
    String IP5 = "192.168.255.255";
    String LOCAL_IP = "127.0.0.1";
    String UNKNOWN = "unknown";
    String PROXY_CLIENT_IP = "Proxy-Client-IP";
    String WL_PROXY_CLIENT_IP = "WL-Proxy-Client-IP";
    String HTTP_CLIENT_IP = "HTTP_CLIENT_IP";
    String HTTP_X_FORWARDED_FOR = "HTTP_X_FORWARDED_FOR";
    String TEST_TOKEN = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiI0IiwiaXNzIjoiaWthbmciLCJleHAiOjI2NDUzNTM5NDgwMywidXNlck5hbWUiOiJhZG1pbkB0ZXN0LmNvbSIsImlhdCI6MTU2MDc1MTYwM30.EjipiTSmOuPPCmfaw8zWKZOe9HhBWTyifhv5OuUQEXs";
    String PASWD_REGEXP = "^[A-Za-z0-9]{32}$";
    String PASWD_UN_PATTERN_MESSAGE = "密码必须是字母和数字组合，且长度在32位";
    String EMAIL = "^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+(;)*(( )*(;)+( )*[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+(;)*)*$";
    Pattern PASSWORD_PATTERN = Pattern.compile(PASWD_REGEXP);
    Pattern EMAIL_PATTERN = Pattern.compile(EMAIL);
    String EMAIL_UN_PATTERN_MESSAGE = "请输入正确邮箱地址";
    String MOBILE_REGEXP = "^(((13[0-9])|(14[0-9])|(15([0-3]|[5-9]))|(17[0-9])|(18[0-9])|(19[0-9])|(16[0-9]))\\d{8})|(0\\d{2}-\\d{8})|(0\\d{3}-\\d{7})*$";
    String MOBILE_REGEXP_MUST = "^(((13[0-9])|(14[0-9])|(15([0-3]|[5-9]))|(17[0-9])|(18[0-9])|(19[0-9])|(16[0-9]))\\d{8})|(0\\d{2}-\\d{8})|(0\\d{3}-\\d{7})+$";
    String URL_REG = "((https?|ftp|file)://[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|])*";
    String DRAFT_REG = "^[0|1|2]$";
    String BUSINESS_STATUS = "^[0|1|2|3]*$";
    String TRACINGTYPE_PATTERN = "^[0|1|2|3|4|5|6]*$";
    String TYPE = "type";
    String ITEM_STATUS = "item_status";
    String CHINA_NAME = "^([\\u4E00-\\u9FA5\\uf900-\\ufa2d·s]{2,20})*$";
    String CHINA_NAME_MUST = "^([\\u4E00-\\u9FA5\\uf900-\\ufa2d·s]{2,20})+$";
    String NUMBER_PATTERN = "^\\d*$";
    String NUMBER_PATTERN_MUST = "^\\d+$";
    String DATE_REG = "((?!0000)[0-9]{4}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)|([0-9]{2}(0[48]|[2468][048]|[13579][26])|(0[48]|[2468][048]|[13579][26])00)-02-29)*";
    String ID_CARD = "^([1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$|^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X))*$";
    String TOKEN_PREFIX = "token:uid:";
    String SMS_LEVEL = "16";
    String SMSNUMBER_KEY_PREFIX = "smsnumber:key:";

    /**
     * 手机号码有效期的验证
     *
     * @Author: zhiyuan.xu@ikang.com
     * @Date: 2019/8/22 20:56
     */
    String SMS_CODE_EXPIRE_KEY = SMSNUMBER_KEY_PREFIX + "expire";

    String SMS_TEMPLATE_ID = "SMS_0";
    int SMS_CODE_EXPIRE_SECOND = 60;
    int SMS_VALUE_SECOND = 300;
    String STR_EMPTY = "";
    String BASE_NUMBER = "0123456789";
    String BASE_CHAR_LW = "abcdefghijklmnopqrstuvwxyz";
    String BASE_CHAR_UP = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    /**
     * 用于随机选的字符和数字
     */
    String BASE_CHAR_NUMBER = BASE_CHAR_LW + BASE_CHAR_UP + BASE_NUMBER;

    /**
     * 用于随机选的字符和数字,去除容易混乱的字符,1--i,l-1,0-o
     */
    String BASE_CHAR_NUMBER_SIMPLE = "23456789abcdefghjkmnpqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ";
    String TOKEN_HEADER = "Authorization";
    String TOKEN_JWT_PREFIX = "token:jwt:";
    String TOKEN_UID_PREFIX = "token:uid:";
    String AUTH_CACHE_AUTH = "auth::authUser_";
    String AUTH_CACHE_USER = "auth::userVo_";
    String AUTH_CACHE_ROLE = "auth::authRole_";
    String AUTH_CACHE_RESOURCE = "auth::authResource_";
    String DATA_SOURCE_1 = "datasource1";
    String DATA_SOURCE_2 = "datasource2";
    String SMS_APPID_PREFIX = "op2c_";
    String PEND_ACTIVITY_BATCH_ID = "op2c:PEND_ACTIVITY_BATCH_ID:";
    String PEND_ACTIVITY_PULL_USER = "op2c:PEND_ACTIVITY_PULL_USER:";
    String PUSH_ACTIVITY_ID = "op2c:PUSH_ACTIVITY_ID:";
    String CLEAR_HISTORY = "op2c:CLEAR_HISTORY:";
    String BEANSTALKD_SMS_TUBE = "sms_yx";
    String TOPIC_OP2C_ACT_MESSAGES = "idata_act_messages";
    String GROUP_OP2C_ACT_MESSAGES = "group_idata_act_messages";
    String FACTORY_OP2C_ACT_MESSAGES = "idataActUserMsgListenerContainerFactory";
    String TOPIC_TAG_USER = "idata_tag_user";
    String GROUP_TAG_USER = "group_idata_tag_user";
    String FACTORY_TAG_USER = "idataTagUserListenerContainerFactory";
    String TOPIC_CARD_USER = "idata_card_user";
    String GROUP_CARD_USER = "group_idata_card_user";
    String FACTORY_CARD_USER = "idataCardUserListenerContainerFactory";
    String TOPIC_SAVE_CARD_DB = "idata_topic_save_card_db";
    String GROUP_CARD_DB = "group_idata_card_db";
    String FACTORY_CARD_DB = "idataCardDBUserListenerContainerFactory";
    String TOPIC_EB_TAG_USER = "idata_EB_tag_user";
    String GROUP_EB_TAG_USER = "group_EB_idata_tag_user";
    String FACTORY_EB_TAG_USER = "idataKafkaListenerContainerFactory4";
    String TOPIC_PROMOTION_USER = "idata_promotion_user";
    String GROUP_PROMOTION_USER = "group_idata_promotion_user";
    String FACTORY_PROMOTION_USER = "idataPromotionUserListenerContainerFactory";
    String IKANG_APP_PUSH_MESSAGE = "ikang_app_push_message";
    String DATA_CLOUD_TELEMARKETING_TOPIC = "ikang_data_cloud_teleMarketing_topic";
    String ISSUER = "ikang";
    String IMAGESCONTENT_KEY_PREFIX = "imagecontent:key:";
    String LONGURL_KEY_PREFIX = "longurl:key:";
    Integer EXIST_PERMANENT = -1;
    String CAPTCHA_KEY_PREFIX = "captcha:key:";
    String SMS_CAPTCHA_KEY_PREFIX = "sms:idata:captcha:key";
    String ACTIVITY_LOGIC_ID = "activity:page:";
    String ACTIVITY_PAGE_ID_MAP = "activity:page:logicId:";
    String LOCATION_PROVINCE_KEY_PREFIX = "location:privince:";
    String LOCATION_CITY_KEY_PREFIX = "location:city:";
    String LOCATION_LIST_PROVINCE_KEY_PREFIX = "location:list:privince";
    String LOCATION_LIST_CITY_KEY_PREFIX = "location:list:city:";
    Integer CAPTCHA_AGE = 600;
    Integer CAPTCHA_SUCCESS_AGE = 60;

    /**
     * Token 有效时长
     */
    int TOKEN_EXPIRE_SECOND = 7 * 24 * 60 * 60;

    /**
     * Token 操作缓存时长，每次操作均会重置该时长，标志用户在一直操作
     */
    int TOKEN_CACHE_SECOND = 7 * 24 * 60 * 60;

    /**
     * token 刷新间隔,[TOKEN_EXPIRE_SECOND - TOKEN_REFRESH_SECOND,TOKEN_EXPIRE_SECOND]之间会刷新Token
     */
    long TOKEN_REFRESH_SECOND = 3600;

    /**
     * 管理员角色CODE
     */
    String ADMIN_ROLE_CODE = "admin";
    String BASIC_ROLE_CODE = "basic";
    String SYS_OPERATOR_ROLE_CODE = "sys:operator";
    String PARAM_USER_NAME = "userName";
    String PARAM_USER_ID = "userId";
    String PARAM_LOGIN_ID = "loginId";
    String PARAM_LOGIC_ID = "logicId";
    String PARAM_SEARCH_BY = "searchBy";
    int INT_0 = 0;
    int INT_1 = 1;
    int INT_2 = 2;
    int INT_3 = 3;
    int INT_4 = 4;
    int INT_5 = 5;
    int INT_6 = 6;
    int INT_10 = 10;
    int INT_100 = 100;
    Integer INTEGER_NEGATIVE_1 = -1;
    Integer INTEGER_NEGATIVE_2 = -2;
    Integer INTEGER_NEGATIVE_3 = -3;
    Integer INTEGER_0 = 0;
    Integer INTEGER_1 = 1;
    Integer INTEGER_2 = 2;
    Integer INTEGER_3 = 3;
    Integer INTEGER_4 = 4;
    Integer INTEGER_5 = 5;
    Integer INTEGER_6 = 6;
    Integer INTEGER_7 = 7;
    Integer INTEGER_8 = 8;
    Integer INTEGER_9 = 9;
    Integer INTEGER_10 = 10;
    Integer INTEGER_100 = 100;
    int NEGATIVE_1 = -1;
    int NEGATIVE_2 = -2;
    int NEGATIVE_3 = -3;
    int NEGATIVE_4 = -4;
    int NEGATIVE_5 = -5;
    long LONG_0 = 0L;
    String STR_0 = "0";
    String STR_1 = "1";
    String STR_2 = "2";
    String STR_3 = "3";
    String STR_4 = "4";
    String STR_5 = "5";
    String STR_10000 = "10000";
    /**
     * 启用、可用、正常
     */
    Integer ENABLE = INT_0;

    /**
     * 禁用、不可用、已删除
     */
    Integer UN_ENABLE = INT_1;

    /**
     * MD5算法
     */
    String ALGORITHM_MD5 = "md5";
    String SAVE_ERROR = "保存失败！";
    String EDIT_ERROR = "编辑失败！";
    String UPDATE_ERROR = "修改失败！";
    String OPERA_ERROR = "操作失败！";
    String CODE = "code";
    String UNDER_LINE = "_";
    String COMMA = ",";
    String AND = "&&";
    String NEXT = "next";
    String SAME = "same";
    String MONTH = "month";
    String PARAM_CARD_ONE = "cardOne";
    String PARAM_CARD_MANY = "cardMany";
    String ACTIVITY_ID = "activityId";
    String BUILDER_QSL = "idataBuildQSL";
    String NUMBER_REGEX = "([1-9]\\d*\\.?\\d*)|(0\\.\\d*[1-9])";
    String THOUSANDS_REGEX = "[\\d\\.\\,]+";
    String NUMBER = "([0-9]\\d*$)";
    String EXPORT_TABLE = "role_return_data_export";
    String LIST_TABLE = "role_return_data";
    String SOURCE = "_source";
    String HITS = "hits";
    String TOTAL = "total";
    String AGGREGATIONS = "aggregations";
    String SCROLL = "scroll";

    /** es查询 获取条数*/
     Integer PAGE_SIZE_9999 = 9999;
     Integer PAGE_SIZE_10000 = 10000;
     Integer PAGE_SIZE_30000 = 30000;


    String RETURN_DATA_CODE = "returnDataCode";
    String RETURN_DATA_NAME = "returnDataName";
    String GROUP_FLAG = "groupFlag";
    String SUM_OR_AVG_FLAG = "sumOrAvgFlag";
    String FIELD_DESC = "fieldDesc";
    Integer DISPLAY = 0;
    String DEFAULT_AGG = "0";
    String COMMON_AGG = "1";
    String DATE_HISTOGRAM = "2";
    String SUM = "sum";
    String AVG = "avg";
    String VALUE = "value";
    String KEY = "key";
    String COUNT = "count";
    String BUCKETS = "buckets";
    String KEY_AS_STRING = "key_as_string";
    String GROUP_BY = "groupBy";
    String DOC_COUNT = "doc_count";
    String START = "start";
    String END = "end";
    String LOW = "low";
    String HIGH = "high";
    String EXPORT_EXCEL = "exportExcel";
    String EXPORT_EXCEL_URL = SLASH + EXPORT_EXCEL;

    String COMMA_SPLIT = ",|，";
    String ASC = "asc";
    String GROUP_SALES = "集团销管";
    String customerType = "customer_type";
    String industryType = "industry_type";
    String projectScale = "project_scale";
    String newOldType = "newoldtype";
    String newSource = "newsource";
    String signMoney = "sign_money";
    String CURRENT_TERM = "currentTerm";
    String SAME_TERM = "sameTerm";
    String MONTH_TERM = "monthTerm";
    String DATA = "data";
    String PROJECT_REDIS_KEY = "idata";
    String SEARCH_REDIS_KEY = "search";
    String BIGDATA = "bigdata";
    String QUERYINTERVAL = "queryInterval";
    String PURCHASE_SALES_DIR = "purchase_sales_dir";
    String PURCHASE_SALES_DEPET_MGR = "purchase_sales_depet_mgr";
    String REG_SELLER_NAME = "reg_seller_name";
    String CHINESE_YES = "是";
    String CHINESE_NO = "否";

    String CAPTCHA_KEY_PREFIX_SMS = "idata:captcha:key:sms";
    int INT_32 = 32;
    /**
     * 常用魔法值 "."
     */
    String STR_DOC = ".";

    /**
     * 邮箱验证码 key 前缀
     */
    String CAPTCHA_KEY_PREFIX_MAIL = "idata:captcha:key:mail";

    /**
     * 员工邮箱
     */
    public static final String USERNAME = "username";
    /**
     * 员工姓名
     */
    public static final String REALNAME = "realname";
    /**
     * 员工手机号
     */
    public static final String USERPHONE = "userphone";
}
```



#### StrPool

```java
public interface StrPool {
    String AMPERSAND = "&";
    String AND = "and";
    String AT = "@";
    String ASTERISK = "*";
    String STAR = "*";
    String BACK_SLASH = "\\";
    String COLON = ":";
    String COMMA = ",";
    String DASH = "-";
    String DOLLAR = "$";
    String DOT = ".";
    String DOTDOT = "..";
    String DOT_CLASS = ".class";
    String DOT_JAVA = ".java";
    String DOT_XML = ".xml";
    String EMPTY = "";
    String EQUALS = "=";
    String FALSE = "false";
    String SLASH = "/";
    String HASH = "#";
    String HAT = "^";
    String LEFT_BRACE = "{";
    String BRACE = "{}";
    String LEFT_BRACKET = "(";
    String LEFT_CHEV = "<";
    String NEWLINE = "\n";
    String N = "n";
    String NO = "no";
    String NULL = "null";
    String OFF = "off";
    String ON = "on";
    String PERCENT = "%";
    String PIPE = "|";
    String PLUS = "+";
    String QUESTION_MARK = "?";
    String EXCLAMATION_MARK = "!";
    String QUOTE = "\"";
    String RETURN = "\r";
    String TAB = "\t";
    String RIGHT_BRACE = "}";
    String RIGHT_BRACKET = ")";
    String RIGHT_CHEV = ">";
    String SEMICOLON = ";";
    String SINGLE_QUOTE = "'";
    String BACKTICK = "`";
    String SPACE = " ";
    String TILDA = "~";
    String LEFT_SQ_BRACKET = "[";
    String RIGHT_SQ_BRACKET = "]";
    String TRUE = "true";
    String UNDERSCORE = "_";
    String UTF_8 = "UTF-8";
    String GBK = "GBK";
    String US_ASCII = "US-ASCII";
    String ISO_8859_1 = "ISO-8859-1";
    String Y = "y";
    String YES = "yes";
    String ONE = "1";
    String ZERO = "0";
    String DOLLAR_LEFT_BRACE = "${";
    String HASH_LEFT_BRACE = "#{";
    String CRLF = "\r\n";
    String HTML_NBSP = "&nbsp;";
    String HTML_AMP = "&amp";
    String HTML_QUOTE = "&quot;";
    String HTML_LT = "&lt;";
    String HTML_GT = "&gt;";
    String STRING_TYPE_NAME = "java.lang.String";
    String LONG_TYPE_NAME = "java.lang.Long";
    String INTEGER_TYPE_NAME = "java.lang.Integer";
    String SHORT_TYPE_NAME = "java.lang.Short";
    String DOUBLE_TYPE_NAME = "java.lang.Double";
    String FLOAT_TYPE_NAME = "java.lang.Float";
    String BOOLEAN_TYPE_NAME = "java.lang.Boolean";
    String SET_TYPE_NAME = "java.lang.Set";
    String LIST_TYPE_NAME = "java.lang.List";
    String COLLECTION_TYPE_NAME = "java.lang.Collection";
    String DATE_TYPE_NAME = "java.util.Date";
    String LOCAL_DATE_TIME_TYPE_NAME = "java.time.LocalDateTime";
    String LOCAL_DATE_TYPE_NAME = "java.time.LocalDate";
    String LOCAL_TIME_TYPE_NAME = "java.time.LocalTime";

    String ARRAY = "Array";
    String INTEGER = "Integer";
    String FLOAT = "Float";
    String DATETIME = "DateTime";
    String DATE = "Date";
    String TIME = "Time";
    String BOOLEAN = "Boolean";


    String HTTPS_PREFIX = "https://";
    String HTTP_PREFIX = "http://";
    String HTTPS = "https";
    String HTTP = "http";
    /**
     * ¬
     * 编码
     */
    String UTF8 = "UTF-8";
    /**
     * JSON 资源
     */
    String CONTENT_TYPE = "application/json; charset=utf-8";

    String HEADER_TOKEN_NAME = "Authorization";
    String TEST_TOKEN = "Bearer test";
    String TEST = "test";
    String PROD = "prod";

    /**
     * 字典服务名
     */
    String DICT_TYPE_SERVICE_NAME = "service_name";

    /**
     * 菜单id
     */
    String RESOURCE_ID = "resourceId";
    /**
     * 电话服务推送RedisKey
     */
    String TELEMARKET_PREFIX = "iData:telemarketing:";

    /**
     * 促到检推送RedisKey
     */
    String FacilitateInspection_PREFIX = "iData:facilitateInspection:";
    /**
     * es相关
     */
    String SOURCE = "_source";
    String SCROLL = "scroll";
    String HITS = "hits";



    /**
     * 默认的根节点path
     */
    String DEF_ROOT_PATH = COMMA;
    /**
     * 默认的父id
     */
    Long DEF_PARENT_ID = 0L;

    String UNKNOW = "unknown";


    /**
     * 用户画像的kafka话题、分组、消费工厂
     */
    String TOPIC_TAG_USER = "idata_tag_user";
    String GROUP_TAG_USER = "group_idata_tag_user";
    String FACTORY_TAG_USER = "idataTagUserListenerContainerFactory";

    /**
     * 短信流水的kafka话题、分组、消费工厂
     */
    String TOPIC_OP2C_ACT_MESSAGES = "idata_act_messages";
    String GROUP_OP2C_ACT_MESSAGES = "group_idata_act_messages";
    String FACTORY_OP2C_ACT_MESSAGES = "idataActUserMsgListenerContainerFactory";


    /**
     * 促销的kafka话题、分组、消费工厂
     */
    String TOPIC_PROMOTION_USER = "idata_promotion_user";
    String GROUP_PROMOTION_USER = "group_idata_promotion_user";
    String FACTORY_PROMOTION_USER = "idataPromotionUserListenerContainerFactory";

    /**
     * 电商活动 kafka话题、分组、消费工厂
     */
    String TOPIC_EB_TAG_USER = "idata_EB_tag_user";
    String GROUP_EB_TAG_USER = "group_EB_idata_tag_user";
    String FACTORY_EB_TAG_USER = "idataKafkaListenerContainerFactory4";

    /**
     * 活动卡的kafka话题、分组、消费工厂
     */
    String TOPIC_CARD_USER = "idata_card_user";
    String GROUP_CARD_USER = "group_idata_card_user";
    String FACTORY_CARD_USER = "idataCardUserListenerContainerFactory";

    String TOPIC_SAVE_CARD_DB="idata_topic_save_card_db";
    String GROUP_CARD_DB = "group_idata_card_db";
    String FACTORY_CARD_DB = "idataCardDBUserListenerContainerFactory";

    /**
     * top
     */
    //电话营销
    String DATA_CLOUD_TELEMARKETING_TOPIC = "ikang_data_cloud_teleMarketing_topic";
    //促到检
    //开始
    String BPROM_PUSH_RECORD = "bprom_push_record";
    //数据
    String BPROM_PUSH_DETAIL = "bprom_push_detail";
    //结束
    String BPROM_PUSH_RECORD_END = "bprom_push_record_end";

    String DATA_CLOUD_MSG_TOPIC = "ikang_data_cloud_message_center_topic";
    String GROUP_IKANG_DATA_CLOUD_MSG = "group_ikang_data_cloud_msg";
    String FACTORY_MSG_USER = "idataMessageListenerContainerFactory";
    String MESSAGE_CENTER_MESSAGE_CENTER = "messageCenter::messageCenter_";
}
```

